这道题又是二分查找的变种。我因为时间有限，想出来的方法是最直接的。

首先先 init 一个 vector {-1,-1}, 这样如果没找到，直接返回无效值。

然后常规手法，二分查找，一旦找到，将 `vec[0] = vec[1] = mid`.

由于咱们找的是一个范围，所以，仅需在这个位置上，前后扩展即可。

```cpp
while (vec[0]>0 && A[vec[0]-1] == target)
    --vec[0];
while (vec[1]<n-1 && A[vec[1]+1] == target)
    ++vec[1];
```

但这里有一个效率的最差情况，就是全部元素都是 target .
我最后的扩展成了 O(n).

针对这种极端情况，我在最开始加上一句判断：
```cpp
if (A[0] == A[n-1] && A[0] == target) return vector<int>{0, n-1};
```

方法不惊艳，希望有更好解法的能告诉我。
