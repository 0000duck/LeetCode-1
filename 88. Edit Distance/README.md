此题乍看之下有点摸不着头脑，但其实属一道非常经典的题目。

有兴趣的童鞋可以看看这个 [Stanford 的 Minimum Edit Distance](http://www.stanford.edu/class/cs124/lec/med.pdf)

-----

而这道小题，只是上述大论题中最简单的情况：连 Replace 操作也仅算一步，各操作都被一视同仁。

我们从实际例子开始分析，看以下几组单词：

```
graffe
graf
    ^^
    insert(2)

graffe
graft
    ^^
    replace + insert

graffe
grail
   ^^^
   replace(2) + insert

graffe
giraffe
 ^
 delete
```

上述就是咱们人脑推断出来的过程，看起来比较直接，一眼就分辨出来了。但如何用代码来表述这个过程，却是一个难题。假设第一个单词为 word1, 长度为 n; 第二个单词为 word2, 长度为 m.

直接去比较 n 与 m 长度的字符串显然无从下手，那么我们简化问题，首先考虑 0 长度，若 m == 0, 则显然应该返回 n， 反之亦然。

```cpp
if (m == 0) return n;
if (n == 0) return m;
```

然后再考虑 n == 1 与 m == 1 的情况. 显然，这就是一个字符的比较，如实例中 `g` 与 `g` 的比较. 如果相同，显然不需要额外操作，如果 m == 2 呢？那就成了 `g` 与 `gr` 的比较，此刻出现两种比较方法：

1. 首先比较 `g` 与 `g`，是相同的，然后发现多了一个 `r`，那么显然就需要一个**删除**操作。`return 1;`
2. 上次比较结果为 0, 此刻多了一个 `r`， 结果+1 为 1.

有人说，这叫什么两种方法，一样啊。细心一点可以发现，完全不同，第一种方法，是分别迭代两个字符串，逐一比较，是类似**枚举**的方法；而第二种，却是基于上一次结论，仅仅关注了 `r`，便得出结论。

**用白话说，善于积累上次结论，是 DP 的思想**

想一想 [29. Unique Paths](../29. Unique Paths)，再想想杨辉三角，就会发现其本质完全一致。
